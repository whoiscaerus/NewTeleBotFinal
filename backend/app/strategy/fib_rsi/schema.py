"""
Pydantic schemas for Fib-RSI strategy signals and execution plans.

This module defines the data structures for trading signals generated by the
strategy and the complete execution plans that result from them.

Models:
    SignalCandidate: A potential trading signal with entry/SL/TP
    ExecutionPlan: Complete plan for executing a signal including position sizing

Example:
    >>> from backend.app.strategy.fib_rsi.schema import SignalCandidate
    >>> from datetime import datetime
    >>>
    >>> signal = SignalCandidate(
    ...     instrument="EURUSD",
    ...     side="buy",
    ...     entry_price=1.0850,
    ...     stop_loss=1.0820,
    ...     take_profit=1.0910,
    ...     confidence=0.85,
    ...     timestamp=datetime.utcnow(),
    ...     reason="rsi_oversold_fib_support",
    ...     payload={"rsi": 25, "roc": 1.2, "fib_level": 0.618}
    ... )
"""

from datetime import datetime
from typing import Any, Optional

from pydantic import BaseModel, Field, validator


class SignalCandidate(BaseModel):
    """Generated trading signal from Fib-RSI strategy.

    Attributes:
        instrument: Trading symbol (e.g., "EURUSD", "GOLD")
        side: Trade direction ("buy" or "sell")
        entry_price: Recommended entry price
        stop_loss: Stop loss price
        take_profit: Take profit price
        confidence: Signal confidence 0.0-1.0
        timestamp: When signal was generated (UTC)
        reason: Human-readable reason for signal (e.g., "rsi_oversold_fib_support")
        payload: Dict with indicator values (RSI, ROC, Fib levels, etc.)
        version: Schema version for compatibility

    Example:
        >>> signal = SignalCandidate(
        ...     instrument="GOLD",
        ...     side="buy",
        ...     entry_price=1950.50,
        ...     stop_loss=1935.00,
        ...     take_profit=1980.50,
        ...     confidence=0.82,
        ...     timestamp=datetime.utcnow(),
        ...     reason="rsi_oversold",
        ...     payload={"rsi": 28, "atr": 15.5}
        ... )
    """

    instrument: str = Field(..., min_length=2, max_length=20, pattern="^[A-Z0-9._-]+$")
    side: str = Field(..., pattern="^(buy|sell)$")
    entry_price: float = Field(..., gt=0, lt=1_000_000)
    stop_loss: float = Field(..., gt=0, lt=1_000_000)
    take_profit: float = Field(..., gt=0, lt=1_000_000)
    confidence: float = Field(..., ge=0.0, le=1.0)
    timestamp: datetime
    reason: str = Field(..., min_length=1, max_length=200)
    payload: dict[str, Any] = Field(default_factory=dict)
    version: str = "1.0"

    class Config:
        """Pydantic config."""

        validate_assignment = True
        arbitrary_types_allowed = True

    @validator("side")
    def validate_side(cls, v: str) -> str:
        """Validate trade side is buy or sell.

        Args:
            v: The side value

        Returns:
            str: The validated side

        Raises:
            ValueError: If side is not "buy" or "sell"
        """
        if v not in ("buy", "sell"):
            raise ValueError(f"side must be 'buy' or 'sell', got {v}")
        return v

    @validator("payload", pre=True, always=True)
    def validate_payload(cls, v: Any) -> dict[str, Any]:
        """Ensure payload is a dict.

        Args:
            v: The payload value

        Returns:
            dict: The payload dict (empty if not provided)
        """
        if v is None:
            return {}
        if not isinstance(v, dict):
            raise ValueError(f"payload must be dict, got {type(v)}")
        return v

    @validator("entry_price", "stop_loss", "take_profit")
    def validate_prices_positive(cls, v: float) -> float:
        """Ensure all prices are positive.

        Args:
            v: Price value

        Returns:
            float: Validated price

        Raises:
            ValueError: If price <= 0
        """
        if v <= 0:
            raise ValueError(f"Price must be > 0, got {v}")
        return v

    def validate_price_relationships(self) -> None:
        """Validate entry/SL/TP relationships are correct for signal direction.

        Raises:
            ValueError: If prices don't match signal direction

        Example:
            >>> signal = SignalCandidate(
            ...     instrument="EURUSD",
            ...     side="buy",
            ...     entry_price=1.0850,
            ...     stop_loss=1.0820,
            ...     take_profit=1.0900
            ... )
            >>> signal.validate_price_relationships()  # Passes
        """
        if self.side == "buy":
            if self.stop_loss >= self.entry_price:
                raise ValueError(
                    f"BUY signal: stop_loss ({self.stop_loss}) "
                    f"must be < entry_price ({self.entry_price})"
                )
            if self.take_profit <= self.entry_price:
                raise ValueError(
                    f"BUY signal: take_profit ({self.take_profit}) "
                    f"must be > entry_price ({self.entry_price})"
                )
        else:  # sell
            if self.stop_loss <= self.entry_price:
                raise ValueError(
                    f"SELL signal: stop_loss ({self.stop_loss}) "
                    f"must be > entry_price ({self.entry_price})"
                )
            if self.take_profit >= self.entry_price:
                raise ValueError(
                    f"SELL signal: take_profit ({self.take_profit}) "
                    f"must be < entry_price ({self.entry_price})"
                )

    def get_risk_pips(self) -> float:
        """Calculate risk in pips from entry to stop loss.

        Returns:
            float: Risk distance in pips (absolute value)

        Example:
            >>> signal = SignalCandidate(
            ...     instrument="EURUSD",
            ...     side="buy",
            ...     entry_price=1.0850,
            ...     stop_loss=1.0820,
            ...     take_profit=1.0900
            ... )
            >>> signal.get_risk_pips()
            30  # pips
        """
        return abs(self.entry_price - self.stop_loss) * 10000

    def get_reward_pips(self) -> float:
        """Calculate reward in pips from entry to take profit.

        Returns:
            float: Reward distance in pips (absolute value)

        Example:
            >>> signal = SignalCandidate(
            ...     instrument="EURUSD",
            ...     side="buy",
            ...     entry_price=1.0850,
            ...     stop_loss=1.0820,
            ...     take_profit=1.0900
            ... )
            >>> signal.get_reward_pips()
            500  # pips
        """
        return abs(self.take_profit - self.entry_price) * 10000

    def get_rr_ratio(self) -> float:
        """Calculate reward:risk ratio.

        Returns:
            float: R:R ratio (reward_pips / risk_pips)

        Raises:
            ZeroDivisionError: If risk is 0 (entry == stop_loss)

        Example:
            >>> signal = SignalCandidate(...)
            >>> signal.get_rr_ratio()
            2.0
        """
        risk = self.get_risk_pips()
        if risk == 0:
            raise ZeroDivisionError("Risk is zero (entry == stop_loss)")
        return self.get_reward_pips() / risk


class ExecutionPlan(BaseModel):
    """Complete execution plan for a trading signal.

    Includes position sizing, risk/reward amounts, and expiry timing.

    Attributes:
        signal: The SignalCandidate this plan is based on
        position_size: Lot size to trade
        risk_amount: Account amount at risk ($)
        reward_amount: Potential reward amount ($)
        risk_reward_ratio: Actual R:R ratio for this execution
        expiry_time: When this signal expires (optional)
        max_holding_hours: Maximum hours to hold position
        entry_confirm_seconds: Seconds to wait for entry confirmation

    Example:
        >>> signal = SignalCandidate(...)
        >>> plan = ExecutionPlan(
        ...     signal=signal,
        ...     position_size=1.0,
        ...     risk_amount=100.0,
        ...     reward_amount=200.0,
        ...     risk_reward_ratio=2.0
        ... )
    """

    signal: SignalCandidate
    position_size: float = Field(..., gt=0, le=100)
    risk_amount: float = Field(..., ge=0)
    reward_amount: float = Field(..., ge=0)
    risk_reward_ratio: float = Field(..., gt=0, le=10)
    expiry_time: Optional[datetime] = None
    max_holding_hours: int = Field(default=24, ge=1, le=240)
    entry_confirm_seconds: int = Field(default=5, ge=1, le=60)

    class Config:
        """Pydantic config."""

        validate_assignment = True
        arbitrary_types_allowed = True

    @validator("risk_reward_ratio")
    def validate_rr_ratio(cls, v: float) -> float:
        """Ensure R:R ratio is within acceptable range.

        Args:
            v: R:R ratio value

        Returns:
            float: Validated ratio

        Raises:
            ValueError: If ratio < 0.5 or > 10
        """
        if not (0.5 <= v <= 10):
            raise ValueError(f"risk_reward_ratio must be 0.5-10, got {v}")
        return v

    def validate_consistency_with_signal(self) -> None:
        """Validate execution plan is consistent with its signal.

        Checks that position sizing and risk/reward amounts make sense
        relative to the signal's entry/SL/TP.

        Raises:
            ValueError: If inconsistencies found

        Example:
            >>> signal = SignalCandidate(...)
            >>> plan = ExecutionPlan(signal=signal, ...)
            >>> plan.validate_consistency_with_signal()
        """
        signal_rr = self.signal.get_rr_ratio()

        # Allow small rounding differences (1%)
        tolerance = 0.01
        ratio_diff = abs(signal_rr - self.risk_reward_ratio) / signal_rr

        if ratio_diff > tolerance:
            raise ValueError(
                f"Signal R:R ({signal_rr:.2f}) doesn't match "
                f"plan R:R ({self.risk_reward_ratio:.2f})"
            )

    def is_expired(self, current_time: datetime) -> bool:
        """Check if execution plan has expired.

        Args:
            current_time: Current time to check against

        Returns:
            bool: True if expiry_time is set and past current_time

        Example:
            >>> from datetime import datetime, timedelta
            >>> signal = SignalCandidate(...)
            >>> plan = ExecutionPlan(
            ...     signal=signal,
            ...     expiry_time=datetime.utcnow() + timedelta(hours=1)
            ... )
            >>> plan.is_expired(datetime.utcnow())
            False
        """
        if self.expiry_time is None:
            return False
        return current_time > self.expiry_time

    def get_position_info(self) -> dict[str, Any]:
        """Get summary position information.

        Returns:
            dict: Position details including side, size, entry, SL, TP

        Example:
            >>> plan = ExecutionPlan(...)
            >>> info = plan.get_position_info()
            >>> info["side"]
            "buy"
        """
        return {
            "instrument": self.signal.instrument,
            "side": self.signal.side,
            "position_size": self.position_size,
            "entry_price": self.signal.entry_price,
            "stop_loss": self.signal.stop_loss,
            "take_profit": self.signal.take_profit,
            "risk_amount": self.risk_amount,
            "reward_amount": self.reward_amount,
            "rr_ratio": self.risk_reward_ratio,
        }
